# 1、两数之和

## length的使用

1. `length`

   length是属性，是**数组**的长度，使用时的形式是：数组`.length`不加括号

2. `length()`

   length()是**字符串**自带的方法，是求字符串长度的，使用形式是：`str.length()`

3. `size()`

   size()是**列表**的自带方法，求的是列表的长度，使用形式是：`list.size()`



2

3

# 4、寻找两个正序数组的中位数

![image-20220922220554936](pic/image-20220922220554936.png)



# 5、最长回文子串

## 中心扩张法

![image-20220920211209159](pic/image-20220920211209159.png)

### 注意

1. 注意出现“aaaa”、“aaa”这样相同字符的回文子串，因此需要在第一个while循环中判断从当前i开始左右是否相同。

2. 在完成相同字符的判断后，进行left-1和right+1同时判断，查找回文数。

3. 时间复杂度：O(n^2)

   空间复杂度：O(1)

   时间换空间

### 替换

1. 将字符串转为数组的方式有：

   ```java
   char[] str = s.toCharArray();
   ```

2. 提取字符串中某一下标的字符：

   ```java
   char st = s.charAt(3);
   ```


## 动态规划

![image-20220920211102615](pic/image-20220920211102615.png)

二维数组是动态规划最常用的方法

### 注意

1. 此方法核心在于按照子串长度进行遍历，判断l长度的子串是否为回文子串，即判断除去两个端点的子串是否为回文子串

2. 1中至少要有三个元素。在只有1个元素时，回文子串就是它自己；有两个元素时，如果两个元素相等则为回文子串。

3. 时间复杂度：O(n^2)

   空间复杂度：O(n^2)



# 11、盛最多水的容器

![image-20220924130921512](pic/image-20220924130921512.png)

逻辑性很强的题目！！

双指针，一个指向最左边，一个指向最右边，这两个指针所指的相对长的板后面称为长板，相对短的板称为短板。

对于左右指针逼近，容器的底边长度一定是在减小。

容器的盛水量取决于底边长度和**短板**。

所以！如果移动短板，可能会遇到更短或者相等的板，那是不幸，容量变小；如果遇到长一些的板子，容量可能变小也可能不变也可能变大。

如果移动长板，底边长度一定减小，如果遇到的是长板，因为容器的高取决于短板，且底边变短，所以容量一定减小；如果遇到比自己短，比短板长的板子，和刚刚一样的道理，也是容量变小；如果遇到比短板还短的板子，那更不用说了，短边变成它自己了，容量一定减小。

因此！富贵险中求！如果移动长板，那容量是一定减少的！如果移动短板，有几率容量变大！

所以设置一个max值，每次移动都记录一下容量，当i与j相遇就说明遍历结束，最后返回max即可。



# 15、三数之和

![image-20220924125048130](pic/image-20220924125048130.png)

1. List<List<Integer>> 的定义

   ```java
   List<List<Integer>> result = new ArrayList<List<Integer>>();
   ```

2. List<Integer>的定义

   ```java
   List<Integer> r = new ArrayList<Integer>()
   ```

3. List的添加操作

   ```java
   list1.add(r);    //r必须是list的<>内的类型，在尾部插入
   ```

4. List的搜索操作

   ```java
   list1.get(index);    //获取list下标为index的数值
   ```

5. int转为Integer

   ```java
   int a;
   Integer b = Integer.valueOf(a);
   ```

6. 数组的排序

   ```java
   Arrays.sort(nums);     //原地修改nums数组
   ```



# 26、删除有序数组中的重复项

![image-20220924130553781](pic/image-20220924130553781.png)

双指针思路



# 68、文本左右对齐

## 方法一、枚举各种情况

![image-20220924200048680](pic/image-20220924200048680.png)

`_1.java`文件为精简版（将很多重复的代码放入函数）

`_2.java`文件更容易理解

`_3.java`文件思路一致，但是更加精简，且易懂⭐

![image-20220924202357372](pic/image-20220924202357372.png)



# 135、分发糖果

## 方法一、递归

![image-20220924183620852](pic/image-20220924183620852.png)

思想：相邻的两个值中，更大的糖果=更小的糖果+1，如果比左右都大则取其max。如果比左右都小，则糖果数为1。用数组记录数值，可以提高时间效率（如果不设置数组，则会超时）。

## 方法二、左右遍历

![image-20220924182743805](pic/image-20220924182743805.png)

思想：从左向右遍历一遍，设置第一个值为1，如果当前值比上一个值大，则糖果数=上一个的糖果数+1，反之将其置为1。此时从左到右的糖果大小关系已经明确。再从右往左遍历一遍，此时只需要一个temp变量记录即可，设置第一个的temp为1，如果当前值比上一个值大，则糖果数=temp+1，对于每一个小朋友都会对他从左遍历和从右遍历取最大值，也就是他最后得到的糖果值。

> 对于 `[1,2,87,87,87,2,1]`
>
> 从左向右：1，2，3，1，1，1，1
>
> 从右向左：1，1，1，1，3，2，1
>
> 综合：1，2，3，1，3，2，1



# 707、设计链表

![image-20220923102230396](pic/image-20220923102230396.png)

Java语言使用链表格式：

```java
class MyLinkedList {
    static class Node {
        int val;
        Node pre;
        Node next;
        public Node() {
        }
        public Node(int val) {
            this.val = val;
        }
    }

    Node head;
    int size=0;

    public MyLinkedList() {
        head = new Node();
        head.next = head;
        head.pre = head;
    }
    
    public int get(int index) {
        Node node = head;
        //......
    }
    //......
}

//调用
MyLinkedList linkedList = new MyLinkedList();
linkedList.get(1);    
```







# 1640、能否连接形成数组

![image-20220922221718430](pic/image-20220922221718430.png)



# 1652、拆炸弹

![image-20220924104449440](pic/image-20220924104449440.png)

负数的求余：

被除数的绝对值与除数绝对值取余的值即为余数绝对值，余数符号与被除数一致。
